# Изменено:
  - Добалена более обширная документация для всех функций


# Методы оценки качества кластеризации

Данный документ описывает функции, реализующие различные методы оценки качества кластеризации. Все функции написаны на языке Python и используют библиотеки `numpy` и `scipy.spatial` для вычисления расстояний.

## 1. Предварительное преобразование данных

### 1.1. `converter_to_c()`

**Описание:**

Функция `converter_to_c` преобразует список точек данных и соответствующие им метки кластеров в структуру данных `C`. В результате получается список кластеров, где каждый кластер содержит точки, принадлежащие ему.

**Сигнатура:**

```python
def converter_to_c(points, labels) -> List:
```

**Параметры:**

- `points` (`List`): Список точек данных. Каждая точка представлена как список координат.
- `labels` (`List`): Список меток кластеров для каждой точки в `points`.

**Возвращаемое значение:**

- `C` (`List`): Список кластеров. Каждый кластер представлен как список точек.

---

## 2. Методы анализа качества кластеризации

### 2.1. `DunnIndex`

**Описание:**

Функция `DunnIndex` вычисляет **индекс Данна** для заданного разбиения на кластеры. Этот индекс используется для оценки качества кластеризации, учитывая минимальное межкластерное расстояние и максимальное внутрикластерное расстояние.

**Сигнатура:**

```python
def DunnIndex(C) -> float:
```

**Параметры:**

- `C` (`List`): Список кластеров, полученный после предварительной обработки данных.

**Возвращаемое значение:**

- `float`: Значение индекса Данна для текущей кластеризации.

**Алгоритм:**

1. Инициализировать `mind` большим числом (например, `100000`), представляющим минимальное межкластерное расстояние.
2. Инициализировать `maxd` нулем, представляющим максимальное внутрикластерное расстояние.
3. Для каждой пары кластеров `(i, j)`:
   - Вычислить минимальное расстояние между кластерами с помощью функции `MinInterCluster(C, i, j)`.
   - Обновить `mind`, если найденное расстояние меньше текущего `mind`.
4. Для каждого кластера `i`:
   - Вычислить максимальное внутрикластерное расстояние с помощью функции `MaxIntraCluster(C, i)`.
   - Обновить `maxd`, если найденное расстояние больше текущего `maxd`.
5. Вычислить и вернуть отношение `mind / maxd` как индекс Данна.

---

### 2.2. `DunnIndexMean`

**Описание:**

Функция `DunnIndexMean` вычисляет модифицированный **индекс Данна**, используя среднее межкластерное расстояние вместо минимального.

**Сигнатура:**

```python
def DunnIndexMean(C) -> float:
```

**Параметры:**

- `C` (`List`): Список кластеров.

**Возвращаемое значение:**

- `float`: Значение модифицированного индекса Данна.

**Алгоритм:**

1. Инициализировать `mind` большим числом и `maxd` нулем.
2. Для каждой пары кластеров `(i, j)`:
   - Вычислить среднее расстояние между кластерами с помощью функции `MeanInterclusterDistance(C, i, j)`.
   - Обновить `mind`, если найденное значение меньше текущего `mind`.
3. Для каждого кластера `i`:
   - Вычислить максимальное внутрикластерное расстояние с помощью `MaxIntraCluster(C, i)`.
   - Обновить `maxd`, если найденное значение больше текущего `maxd`.
4. Вычислить и вернуть отношение `mind / maxd`.

---

## 3. Дополнительные функции

### 3.1. `MinInterCluster`

**Описание:**

Вычисляет минимальное расстояние между двумя кластерами `i` и `j`.

**Сигнатура:**

```python
def MinInterCluster(C, i, j) -> float:
```

**Параметры:**

- `C` (`List`): Список кластеров.
- `i` (`int`): Индекс первого кластера.
- `j` (`int`): Индекс второго кластера.

**Возвращаемое значение:**

- `float`: Минимальное расстояние между точками кластеров `i` и `j`.

**Алгоритм:**

1. Инициализировать `mind` большим числом.
2. Для каждой точки `i1` в кластере `C[i]`:
   - Для каждой точки `j1` в кластере `C[j]`:
     - Вычислить евклидово расстояние между `i1` и `j1`.
     - Если расстояние меньше `mind`, обновить `mind`.

---

### 3.2. `MaxIntraCluster`

**Описание:**

Вычисляет максимальное расстояние между точками внутри кластера `i`.

**Сигнатура:**

```python
def MaxIntraCluster(C, i) -> float:
```

**Параметры:**

- `C` (`List`): Список кластеров.
- `i` (`int`): Индекс кластера.

**Возвращаемое значение:**

- `float`: Максимальное расстояние между точками внутри кластера `i`.

**Алгоритм:**

1. Инициализировать `maxd` нулем.
2. Для каждой пары различных точек `i1` и `j1` в кластере `C[i]`:
   - Вычислить евклидово расстояние между `i1` и `j1`.
   - Если расстояние больше `maxd`, обновить `maxd`.

---

### 3.3. `MeanInterclusterDistance`

**Описание:**

Вычисляет среднее расстояние между двумя кластерами `i` и `j`.

**Сигнатура:**

```python
def MeanInterclusterDistance(C, i, j) -> float:
```

**Параметры:**

- `C` (`List`): Список кластеров.
- `i` (`int`): Индекс первого кластера.
- `j` (`int`): Индекс второго кластера.

**Возвращаемое значение:**

- `float`: Среднее расстояние между точками кластеров `i` и `j`.

**Алгоритм:**

1. Вычислить нормализующий множитель: `norm = 1 / (len(C[i]) * len(C[j]))`.
2. Инициализировать сумму расстояний `sum` нулем.
3. Для каждой точки `i1` в кластере `C[i]`:
   - Для каждой точки `j1` в кластере `C[j]`:
     - Вычислить евклидово расстояние между `i1` и `j1` и добавить к `sum`.
4. Умножить `sum` на `norm` для получения среднего расстояния.

---

## 4. Индекс Дэвиса-Болдина (DBI)

### 4.1. `DBi`

**Описание:**

Функция `DBi` вычисляет **индекс Дэвиса-Болдина** между двумя кластерами `l` и `k`. Этот индекс оценивает соотношение внутрикластерной дисперсии к межкластерному расстоянию.

**Сигнатура:**

```python
def DBi(C, l, k, p, q) -> float:
```

**Параметры:**

- `C` (`List`): Список кластеров.
- `l` (`int`): Индекс первого кластера.
- `k` (`int`): Индекс второго кластера.
- `p` (`int`): Порядок нормы для вычисления расстояния между точками и центроидами.
- `q` (`int`): Порядок нормы для суммирования внутрикластерных расстояний.

**Возвращаемое значение:**

- `float`: Значение индекса Дэвиса-Болдина для кластеров `l` и `k`.

**Алгоритм:**

1. Вычислить внутрикластерное рассеяние для кластеров `l` и `k` с помощью `IntraclusterSeparation`.
2. Вычислить межкластерное расстояние между центроидами кластеров `l` и `k` с помощью `InterclusterSeparation`.
3. Вычислить отношение суммы внутрикластерных рассеяний к межкластерному расстоянию.

---

### 4.2. Вспомогательные функции для DBi

#### 4.2.1. `normp`

**Описание:**

Вычисляет норму порядка `p` между двумя векторами `u` и `v`.

**Сигнатура:**

```python
def normp(p, u, v) -> float:
```

**Параметры:**

- `p` (`int`): Порядок нормы (например, `p=2` для евклидовой нормы).
- `u` (`List`): Первый вектор.
- `v` (`List`): Второй вектор.

**Возвращаемое значение:**

- `float`: Значение нормы порядка `p` между `u` и `v`.

**Алгоритм:**

1. Инициализировать сумму `sum` нулем.
2. Для каждой координаты `i`:
   - Вычислить абсолютную разницу `|u[i] - v[i]|` и возвести в степень `p`.
   - Добавить полученное значение к `sum`.
3. Возвести `sum` в степень `1/p` и вернуть результат.

---

#### 4.2.2. `Mi`

**Описание:**

Вычисляет центроид (среднее значение координат) кластера `i`.

**Сигнатура:**

```python
def Mi(C, i) -> List:
```

**Параметры:**

- `C` (`List`): Список кластеров.
- `i` (`int`): Индекс кластера.

**Возвращаемое значение:**

- `List`: Координаты центроида кластера `i`.

**Алгоритм:**

1. Инициализировать список `mi` нулями длиной, равной количеству измерений точек.
2. Для каждой точки `i1` в кластере `C[i]`:
   - Для каждой координаты `j`:
     - Добавить значение координаты `i1[j]` к `mi[j]`.
3. Разделить каждую сумму в `mi` на количество точек в кластере для получения среднего значения.

---

#### 4.2.3. `IntraclusterSeparation`

**Описание:**

Вычисляет внутрикластерное рассеяние для кластера `i`.

**Сигнатура:**

```python
def IntraclusterSeparation(C, i, p, q) -> float:
```

**Параметры:**

- `C` (`List`): Список кластеров.
- `i` (`int`): Индекс кластера.
- `p` (`int`): Порядок нормы для расстояния между точками и центроидом.
- `q` (`int`): Порядок нормы для суммирования расстояний.

**Возвращаемое значение:**

- `float`: Внутрикластерное рассеяние кластера `i`.

**Алгоритм:**

1. Вычислить центроид кластера `M` с помощью `Mi(C, i)`.
2. Инициализировать сумму `sum` нулем.
3. Для каждой точки `i1` в кластере `C[i]`:
   - Вычислить `normp(p, i1, M)` и возвести результат в степень `q`.
   - Добавить полученное значение к `sum`.
4. Нормализовать сумму, разделив на количество точек в кластере.
5. Возвести результат в степень `1/q` и вернуть.

---

#### 4.2.4. `InterclusterSeparation`

**Описание:**

Вычисляет расстояние между центроидами кластеров `l` и `k`.

**Сигнатура:**

```python
def InterclusterSeparation(C, l, k, p) -> float:
```

**Параметры:**

- `C` (`List`): Список кластеров.
- `l` (`int`): Индекс первого кластера.
- `k` (`int`): Индекс второго кластера.
- `p` (`int`): Порядок нормы для вычисления расстояния.

**Возвращаемое значение:**

- `float`: Расстояние между центроидами кластеров `l` и `k`.

**Алгоритм:**

1. Вычислить центроиды кластеров `u` и `v` с помощью `Mi(C, l)` и `Mi(C, k)`.
2. Вычислить и вернуть норму `normp(p, u, v)`.

---

## 5. Примечания

- **Выбор метрики расстояния:** В функциях для вычисления расстояний между точками по умолчанию используется евклидово расстояние (`distance.euclidean` из `scipy.spatial`). При необходимости вы можете заменить его на другую метрику расстояния.
- **Индексы кластеров:** В коде индексы кластеров начинаются с `0`. При использовании меток кластеров убедитесь, что они соответствуют этому соглашению.
- **Параметры `p` и `q`:** В функциях, где используются нормы порядка `p` и `q`, вы можете задать эти параметры в зависимости от ваших потребностей. Например, `p=2` соответствует евклидовой норме.

---

## 6. Авторы

- **Николаев М. А.**
- **Федоров А. В.**
- **Грибан М. С.**
- **Козлов А. И.**
